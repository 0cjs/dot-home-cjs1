#!/usr/bin/env bash
#
#  Run a command when files are written
#
#  When saving a file, editors such a vim do not truncate the file and
#  write the new data but instead move the file away, create and write
#  a new file, and then remove the old one. That means we need to
#  watch the directory, not the file, for changes.
#
#  We don't use `-r` because on a top level directory this will watch
#  build directories, too. Need to find a way to watch `.`
#  non-recursively but certain subdirs recursively.
#

EX_USAGE=64     # sysexits.h

warn() { echo >&2 -e "$(basename $0):" "$@"; }
die()  { warn "$@"; exit 1; }

set_git_watchlist() {
    declare -ga watchlist
    while read file; do
        watchlist+=("$file")
    done < <( set -o pipefail
      git ls-files -c -o 2>/dev/null | sed -e 's,/.*,/,' | sort -u
    )
}

print_separator() {
    local cols=$(tput cols)
    echo
    #   Not that we care much about efficiency here,
    #   but the following uses only Bash built-ins.
    for ((i=0; i<$((${cols:-80} - 1)); ++i)); do echo -n '━'; done; echo
    echo
}

usage() {
    cat >&2 <<____
Usage: $(basename $0) [-v] [-f FILE] ...  COMMAND ...
    -f FILE     Add a file to watch (directories recursively); multiple allowed.
                Default list is files tracked by Git in/under CWD.
    -s          Suppress the separator lines between runs.
    -v          Verbose; show events and other information.
    COMMAND     Command to run; interpted by shell.
____
    exit $EX_USAGE
}

####################################################################

type inotifywait >/dev/null \
    || die "Can't run inotifywait. Install inotify-tools?"

quiet=:
separator=
watchlist=()
while true; do case "$1" in
    -f)     shift; watchlist+=("$1"); shift ;;
    -v)     shift; quiet= ;;
    -s)     shift; separator=: ;;
    -*)     warn "Unknown option: $1\n"; usage;;
    *)      break;;
esac; done
[ -z "$1" ] && usage

[[ "${#watchlist}" -gt 0 ]] || set_git_watchlist

$quiet echo "Watching: ${watchlist[@]}"
inotifywait --monitor ${quiet:+--quiet} --event close_write \
    --exclude '^./.git/' --recursive "${watchlist[@]}" \
    | while read event; do
        $separator print_separator

        $quiet echo "#  Received: $event"
        $quiet echo "#   Running: $@"
        (. ~/.bashrc && "$@")

        #   After the first event that triggered the command run there may
        #   have immediately been further events if multiple files were
        #   written or if the written file was in a subdirectory,
        #   triggering a directory write. There may also have been further
        #   events yet from files written during the command run, such as
        #   (re)compiled Python bytecode. We read and ignore all these so
        #   that we don't trigger multiple runs from what the user sees as
        #   one "save" event.
        while read -t 0.5 event; do
            $quiet echo "#  Ignoring: $event"
        done
    done
