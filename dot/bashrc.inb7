# Late-ish running setup for full cjs environment

#############################################################
# Bash Configuration

__cjs_prompt() {
    local exitcode="$?"

    #   \001…\002 tells readline not to count these as printing chars.
    #   This can be done as \[…\] in some circumstances, but not all.
    #   See: https://stackoverflow.com/q/24839271/107294
    local      none=$'\001\E[m\002'
    local      bold=$'\001\E[01m\002'
    local underline=$'\001\E[01m\002'
    local       inv=$'\001\E[07m\002'
    local       red=$'\001\E[31m\002'
    local     green=$'\001\E[32m\002'
    local    yellow=$'\001\E[33m\002'
    local      blue=$'\001\E[34m\002'
    local  bgyellow=$'\001\E[43m\002'
    local   bgwhite=$'\001\E[47m\002'
    local   boldred=$'\001\E[1;31m\002'
    #   Above is mostly documentation for further use elsewhere;
    #   we should probably extract it.
    local    pcolor="$blue$bold"

    local exitprint
    case "$exitcode" in
        0) exitprint='' ;;
        *) exitprint="${red}${exitcode}${none} ";;
    esac

    case `id -u -n` in
        root)               echo "$exitprint$pcolor#$none ";;
        cjs|curt*|samp*)    echo "$exitprint$pcolor\$$none ";;
        *)                  echo "$(id -u -n) $exitprint$pcolor\$$none ";;
    esac
}
PS1='$(__cjs_prompt)'


############################################################
# Handy aliases

sk()            {
    env | grep '^SSH_AUTH_SOCK=' \
        || echo 1>&2 "Warning: SSH_AUTH_SOCK not set in environment"
    ssh-add -l "$@"
}
d()     { sudo docker "$@"; };  complete -F _docker d

findf() {
    [ -z "$1" ] && {
        echo 1>&2 "Usage: findf DIR ... [NAME-FRAGMENT [FIND-OPS ...]]"
        return 2;
    }
    local roots=() namefrag
    while [ -e "$1" ]; do roots+=("$1"); shift; done
    local name_frag="$1"; shift
    local predicate=-iname
    [[ $name_frag =~ / ]] && predicate=-ipath
    find -L "${roots[@]}" -type f $predicate "*$name_frag*" "$@" 2>/dev/null
}


############################################################
# Python virtualenvwrapper (mkvirtualenv, workon, deactivate, etc.)
# Not sure that hardcoding /usr/bin/python3 is the best way to do this.
if [[    -z $WORKON_HOME \
      && -r ~/.local/bin/virtualenvwrapper.sh \
      && -x /usr/bin/python3 \
]]; then
    export VIRTUALENVWRAPPER_PYTHON=/usr/bin/python3
    export WORKON_HOME=~/co/py-virtualenv
    if [ -r $WORKON_HOME/initialize ]; then
        . ~/.local/bin/virtualenvwrapper.sh
    else
        # An initial setup of an empty $WORKON_HOME logs annoying messages
        # at logger info level which by default goes to stderr.
        . ~/.local/bin/virtualenvwrapper.sh 2>&1 \
            | grep -v "^virtualenvwrapper.user_scripts creating $WORKON_HOME"
    fi
fi
