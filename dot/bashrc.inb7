# Late-ish running setup for full cjs environment

############################################################
# Environment

#   I18N  settings
#   We don't set LANGUAGE anymore; I'm not sure why I used to do that.
unset  LC_ALL               # This overrides all other L* vars; that's bad!
export LANG=en_US.UTF-8
export LC_COLLATE=C         # I prefer to sort in case-sensitive ASCII order
#   Get rid of stuff the system might cleverly try to set for me.
unset LC_TIME LC_MONETARY LC_ADDRESS LC_TELEPHONE LC_NAME LC_MEASUREMENT
unset LC_IDENTIFICATION LC_NUMERIC LC_PAPER LC_CTYPE

#   Editors and pagers
export EDITOR=vim
export VISUAL=vim
export PAGER=less
export LESS='-aeFimsXR -j.15'
#   systemd overrides $LESS options w/"FRSXMK", and we want our LESS without -F
export SYSTEMD_LESS='-aeimsXR -j.15'

#   Other programs
#   Turn off damn colours when using ls.
export LS_COLORS='no=00:fi=00:di=00:ln=00:pi=00:so=00:do=00:bd=00:cd=00:or=00:ex=00:*=00:'
export SUDO_PROMPT="sudo pw for %u@%H: "
export RSYNC_RSH=ssh
export GOPATH=$HOME/co/golang


#############################################################
# Bash Configuration

#   Keep history only in RAM to avoid security issues.
unset HISTFILE

#   Update xterm title bar
export PROMPT_COMMAND=xtitle

__cjs_prompt() {
    local exitcode="$?"

    #   \001…\002 tells readline not to count these as printing chars.
    #   This can be done as \[…\] in some circumstances, but not all.
    #   See: https://stackoverflow.com/q/24839271/107294
    local      none=$'\001\E[m\002'
    local      bold=$'\001\E[01m\002'
    local underline=$'\001\E[01m\002'
    local       inv=$'\001\E[07m\002'
    local       red=$'\001\E[31m\002'
    local     green=$'\001\E[32m\002'
    local    yellow=$'\001\E[33m\002'
    local      blue=$'\001\E[34m\002'
    local  bgyellow=$'\001\E[43m\002'
    local   bgwhite=$'\001\E[47m\002'
    local   boldred=$'\001\E[1;31m\002'
    #   Above is mostly documentation for further use elsewhere;
    #   we should probably extract it.
    local    pcolor="$blue$bold"

    local exitprint
    case "$exitcode" in
        0) exitprint='' ;;
        *) exitprint="${red}${exitcode}${none} ";;
    esac

    case `id -u -n` in
        root)               echo "$exitprint$pcolor#$none ";;
        cjs|curt*|samp*)    echo "$exitprint$pcolor\$$none ";;
        *)                  echo "$(id -u -n) $exitprint$pcolor\$$none ";;
    esac
}
PS1='$(__cjs_prompt)'

# Most systems (Debian 8, CentOS 7) you can just `shopt -s progcomp`
# and `/etc/profile.d/bash_completion.sh` will take care of this.
# But doing this ourselves means we don't turn on `progcomp` unless
# we have the `bash_completion` script to run.
#
if ! shopt -oq posix; then
    if [ -f /usr/share/bash-completion/bash_completion ]; then
        . /usr/share/bash-completion/bash_completion
    elif [ -f /etc/bash_completion ]; then
        . /etc/bash_completion
    elif [ -f /usr/local/etc/bash_completion ]; then
        . /usr/local/etc/bash_completion    # MacOS X Homebrew
    fi
fi

set -o vi vi-tabcomplete


############################################################
# Handy aliases

idat()          { date "+%y%m%d" "$@"; }
idate()         { date "+%Y%m%d" "$@"; }
i-date()        { date "+%Y-%m-%d"; }
i-datew()       { date "+%Y-%m-%d %a"; }
itime()         { date "+%Y%m%d-%H%M%S" "$@"; }
i-time()        { date "+%Y-%m-%d %H:%M"; }

lf()            { ls -CF "$@"; }
lfa()           { ls -CFa "$@"; }
ll()            { ls -lh "$@"; }
lla()           { ll -a "$@"; }
llt()           { ll -t "$@"; }
llth()          { ll -t "$@" | head; }

findf() {
    [ -z "$1" ] && {
        echo 1>&2 "Usage: findf DIR ... [NAME-FRAGMENT [FIND-OPS ...]]"
        return 2;
    }
    local roots=() namefrag
    while [ -e "$1" ]; do roots+=("$1"); shift; done
    local name_frag="$1"; shift
    local predicate=-iname
    [[ $name_frag =~ / ]] && predicate=-ipath
    find -L "${roots[@]}" -type f $predicate "*$name_frag*" "$@" 2>/dev/null
}

dum()           { du -ms "$@" | sort -n; }
dfh()  {
    if [ $(uname) = Linux ]; then
        df -hT -x tmpfs -x devtmpfs -x debugfs "$@" \
            | sed -e '/^[^ ]*$/N' -e 's/\n//g' \
                -e 's/Use%/Use/' -e 's/Avail/Free/' \
            | while read fs type size used avail use mounted; do
                  printf '%-31s %-4.4s %4s %5s %3s %4s %s\n' \
                      $(echo "$fs" | sed -e 's,/dev/,,') \
                      "$type" "$size" "$used" "$use" "$avail" "$mounted"
              done
    else
        df -h "$@"
    fi
}

scl()           { systemctl "$@"; }
more()          { less "$@"; }
nman()          { nroff -mandoc "$@" | less; }
sortip()        { sort -n -t . -k1,1 -k2,2 -k3,3 -k4,4 "$@"; }

ssha()          { ssh -o StrictHostKeyChecking=ask "$@"; }
sk()            {
    env | grep '^SSH_AUTH_SOCK=' \
        || echo 1>&2 "Warning: SSH_AUTH_SOCK not set in environment"
    ssh-add -l "$@"
}

dr() {
    local sudo=
    [[ -w /var/run/docker.sock ]] || sudo=sudo
    $sudo docker "$@";
};  complete -F _docker dr
# XXX The _docker function isn't loaded until we type `docker <TAB>`;
# we should load it ourselves here or enable autoload for it somehow.

######################################################################
# Python virtualenvwrapper (mkvirtualenv, workon, deactivate, etc.)

if [[ -r ~/.local/bin/virtualenvwrapper.sh ]]; then
    [[ -z $VIRTUALENVWRAPPER_PYTHON && -x /usr/bin/python3 ]] \
        && export VIRTUALENVWRAPPER_PYTHON=/usr/bin/python3
    [[ -z $WORKON_HOME ]] \
        && export WORKON_HOME=~/co/py-virtualenv
    if [[ -r $WORKON_HOME/initialize ]]; then
        . ~/.local/bin/virtualenvwrapper.sh
    else
        # An initial setup of an empty $WORKON_HOME logs annoying messages
        # at logger info level which by default goes to stderr.
        . ~/.local/bin/virtualenvwrapper.sh 2>&1 \
            | grep -v "^virtualenvwrapper.user_scripts creating $WORKON_HOME"
    fi
fi
