# Late-ish running setup for full cjs environment

#############################################################
# Bash Configuration

#   Keep history only in RAM to avoid security issues.
unset HISTFILE

#   Update xterm title bar before each prompt if xtitle is available
[[ ! -v PROMPT_COMMAND ]] && xtitle -x >/dev/null 2>&1 && PROMPT_COMMAND=xtitle

#   Variables used by the prompt. These avoid running the commands every time
#   we print the prompt, for slight efficiency gain. We never export them
#   because other processes should do their own checks on their environment.
__cjs_prompt_user="$(id -u -n)"
grep -q -s ':/docker/' /proc/1/cgroup && __cjs_prompt_docker=1

__cjs_prompt() {
    local exitcode="$?"

    #   \001…\002 tells readline not to count these as printing chars.
    #   This can be done as \[…\] in some circumstances, but not all.
    #   See: https://stackoverflow.com/q/24839271/107294
    local      bold=$'\001\E[01m\002'
    local underline=$'\001\E[01m\002'
    local       inv=$'\001\E[07m\002'
    local       red=$'\001\E[31m\002'
    local     green=$'\001\E[32m\002'
    local    yellow=$'\001\E[33m\002'
    local      blue=$'\001\E[34m\002'
    local  bgyellow=$'\001\E[43m\002'
    local   bgwhite=$'\001\E[47m\002'
    local   boldred=$'\001\E[1;31m\002'
    local      none=$'\001\E[m\002'         # At end so `declare -f` looks ok
    #   Above is mostly documentation for further use elsewhere;
    #   we should probably extract it.
    local    pcolor="$blue$bold"

    local exitprint
    case "$exitcode" in
        0) exitprint='' ;;
        *) exitprint="${red}${exitcode}${none} ";;
    esac

    local pp=''                                         # prompt prefix for:
    [[ -n $__cjs_prompt_docker ]] && pp="${pp}d"        # - docker
    [[ -n $STY ]] && pp="${pp}s"                        # - screeen

    if [[ $EUID -eq 0 ]]; then
        echo "$exitprint$pcolor$pp#$none "
    elif [[ $__cjs_prompt_user =~ ^(cjs|curt|c?samp) ]]; then
        echo "$exitprint$pcolor$pp\$$none "
    else
        echo "$__cjs_prompt_user $exitprint$pcolor$pp\$$none "
    fi
}
PS1='$(__cjs_prompt)'

# Most systems (Debian 8, CentOS 7) you can just `shopt -s progcomp`
# and `/etc/profile.d/bash_completion.sh` will take care of this.
# But doing this ourselves means we don't turn on `progcomp` unless
# we have the `bash_completion` script to run.
#
if ! shopt -oq posix; then
    if [ -f /usr/share/bash-completion/bash_completion ]; then
        . /usr/share/bash-completion/bash_completion
    elif [ -f /etc/bash_completion ]; then
        . /etc/bash_completion
    elif [ -f /usr/local/etc/bash_completion ]; then
        . /usr/local/etc/bash_completion    # MacOS X Homebrew
    fi
fi

if shopt -q progcomp; then
    ~/.local/share/bash-completion/generate-completions
    for i in ~/.local/share/bash-completion/completions/*; do
        [[ -r "$i" ]] && source "$i"
    done
fi

#   Copy a completion to an alias, assuming standard autoload coventions of
#   the bash-completion package. (Actually, doesn't quite work because some
#   completions use __$command as the function instead of _$command.)
#
usecompletion() {
    local command="$1" alias="$2"
    local -a compdirs=(
        ~/.local/share/bash-completion/completions
        /usr/share/bash-completion/completions
        /etc/back_completion.d
    )
    for compdir in "${compdirs[@]}"; do
        local compfile=$compdir/$command
        [[ -r $compfile ]] && { . $compfile; break; }
    done
    complete -F _$command $alias
}


set -o vi


############################################################
# Handy aliases

#   Similar functionality will be added to the dot-home system,
#   but in the meantime we have this quickie:
re() { dot-home-setup "$@"; . $HOME/.bashrc; }

#   My `cd` sets CWD after dereferencing symlinks.
#   If we deref, print the actual dir to stdout after the change.
#
#   We really should look at whether we should be using this technique,
#   aliasing `cd` to `cd -P`, or just setting `-o physical`. As well as
#   what gets printed, there's also the isssue of how `..` is treated
#   in the argument.
#
cd() {
    local oldpwd="$(pwd -P)"
    command cd "$@" || return $?
    #   Bash keeps cwd info independent of $PWD, so we can't just reset that.
    if [ "$(pwd -L)" != "$(pwd -P)" ]; then
        CDPATH="" command cd "$(pwd -P)" || return $?
        #   We print to stdout because that's what `cd` itself does when
        #   given `-` or changing to a directory found via $CDPATH.
        pwd
    fi
    OLDPWD="$oldpwd"
}

#   Blank lines make following text easier to find in terminal scrollback.
sp() { local i=0; while [ $i -lt ${1:-5} ]; do echo; i=$(($i+1)); done; }

#   Quick command-line calculator; leaves result in $last
calc() {
    local scale=2
    while true; do case "$1" in
        -[0-9][0-9])    scale="${1#-}"; shift;;
        -[0-9])         scale="${1#-}"; shift;;
        *)              break;;
    esac; done
    if [[ -z $1 ]]; then  # interactive mode, with given scale.
        (echo "scale=$scale"; cat) | bc -q
    else
        #   $last is available after this function exits à la the
        #   "last" variable in bc. `declare -g` isn't available in
        #   Bash <4.2, so there we just set it without declaring it
        #   local and hope for the best.
        declare -g last || true
        last=$((echo "scale=$scale"; echo "$@") | bc -q \
            | sed -e '/\./s/0*$//' -e 's/\.$//') # remove trailing 0s
        echo "$last"
    fi
}


idat()          { date "+%y%m%d" "$@"; }
idate()         { date "+%Y%m%d" "$@"; }
i-date()        { date "+%Y-%m-%d"; }
i-datew()       { date "+%Y-%m-%d %a"; }
itime()         { date "+%Y%m%d-%H%M%S" "$@"; }
i-time()        { date "+%Y-%m-%d %H:%M"; }

#   This is aliased by some default .bashrc configurations.
unalias ll 2>/dev/null || true

lf()            { ls -CF "$@"; }
lfa()           { lf -a "$@"; }
ll()            { ls -lh "$@"; }
lla()           { ll -a "$@"; }
llt()           { ll -t "$@"; }
llth()          { ll -t "$@" | head; }

findf() {
    [ -z "$1" ] && {
        echo 1>&2 "Usage: findf DIR ... [NAME-FRAGMENT [FIND-OPS ...]]"
        return 2;
    }
    local roots=() namefrag
    while [ -e "$1" ]; do roots+=("$1"); shift; done
    local name_frag="$1"; shift
    local predicate=-iname
    [[ $name_frag =~ / ]] && predicate=-ipath
    find -L "${roots[@]}" -type f $predicate "*$name_frag*" "$@" 2>/dev/null
}

#   While this provides memory usage information, it always runs a
#   subprocess and so can't be used to time built-in shell commands.
#   For that, use the built-in `time`.
tm() {
    local time=/usr/bin/time
    [ $(uname) = Darwin ] && time=/usr/local/bin/gtime
    $time --format '%e user=%U system=%S rss=%MK' "$@"
}

dum()           { du -ms "$@" | sort -n; }
dfh()  {
    if [ $(uname) = Linux ]; then
        df -hT -x tmpfs -x devtmpfs -x debugfs "$@" \
            | sed -e '/^[^ ]*$/N' -e 's/\n//g' \
                -e 's/Use%/Use/' -e 's/Avail/Free/' \
            | while read fs type size used avail use mounted; do
                  printf '%-31s %-4.4s %4s %5s %3s %4s %s\n' \
                      $(echo "$fs" | sed -e 's,/dev/,,') \
                      "$type" "$size" "$used" "$use" "$avail" "$mounted"
              done
    else
        df -h "$@"
    fi
}

scl()           { systemctl "$@"; }; usecompletion systemctl scl
more()          { less "$@"; }
nman()          { nroff -mandoc "$@" | less; }
sortip()        { sort -n -t . -k1,1 -k2,2 -k3,3 -k4,4 "$@"; }

ssha()          { ssh -o StrictHostKeyChecking=ask "$@"; }
sk()            {
    env | grep '^SSH_AUTH_SOCK=' \
        || echo 1>&2 "Warning: SSH_AUTH_SOCK not set in environment"
    ssh-add -l "$@"
}

dr() {
    local sudo=
    [[ -w /var/run/docker.sock ]] || sudo=sudo
    $sudo docker "$@";
};  usecompletion docker dr


############################################################
#   Editor functions

#   On some systems (CentOS), `/usr/bin/vi` is vim-tiny even though
#   a full version of Vim is available in `/usr/bin/vim`. On others
#   there exists `/usr/bin/vi` but no `/usr/bin/vim`. Ensure that all
#   of `vi`, `vim` and `view` give us the best available editor.
#   (This depends on our profile setting up $VISUAL correctly.)
#   We must unalias _outside_ the block because it fails to parse
#   before execution if the aliases are set.
#
unalias vi vim view vil 2>/dev/null || true
[[ $VISUAL = *vi* ]] && {
    vi()    { command "$VISUAL" "$@"; }
    vim()   { command "$VISUAL" "$@"; }
    view()  { command "$VISUAL" -R "$@"; }
    vil()   { command "$VISUAL" -c "normal '0" "$@"; }  # vim at last location
}

# vc - edit files listed by output of a command
#
# This doesn't work in many circumstances:
#   * When vc is not the first command on the line.
#   * In most non-Bash shells, though they can at least parse it
#     without errors.
#   * Probably others I've not thought of.
#
# This is a tricky combination of shell alias and function so that we
# can avoid having to quote the command given to vc. Not only is this
# more convenient for the use of vc itself, but it also lets us try out
# the command alone and, when it generates the list of files in which
# we're interested, go back in the history and simply prepend "vc " to
# it to edit those files.
#
# Basically, the vc alias ignores all of its arguments as a comment
# and just calls the vc_literal function. This, however, leaves the
# unprocessed arguments in the shell history which we can then extract
# using the bash history command and use to create a new command line
# which we can then evaluate.
#
# For a detailed analysis of this and related tricks, see
#   http://www.chiark.greenend.org.uk/~sgtatham/aliases.html
#
alias vc="vc_literal #"
vc_literal() {
    cmd=$(history 1 | sed -e 's/ *[0-9]\+ *vc *//')
    #echo "raw: $cmd"
    #echo -n "eval: "; eval "$cmd"
    "$EDITOR" $(eval "$cmd")
}


######################################################################
# Python stuff

#   Python multi-version installation manager
[[ -s ~/.pythonz/etc/bashrc ]] && . ~/.pythonz/etc/bashrc

#   Python virtualenvwrapper (mkvirtualenv, workon, deactivate, etc.)
if [[ -r ~/.local/bin/virtualenvwrapper.sh ]]; then
    [[ -z $VIRTUALENVWRAPPER_PYTHON && -x /usr/bin/python3 ]] \
        && export VIRTUALENVWRAPPER_PYTHON=/usr/bin/python3
    [[ -z $WORKON_HOME ]] \
        && export WORKON_HOME=~/co/py-virtualenv
    if [[ -r $WORKON_HOME/initialize ]]; then
        . ~/.local/bin/virtualenvwrapper_lazy.sh
    else
        # An initial setup of an empty $WORKON_HOME logs annoying messages
        # at logger info level which by default goes to stderr.
        . ~/.local/bin/virtualenvwrapper.sh 2>&1 \
            | grep -v "^virtualenvwrapper.user_scripts creating $WORKON_HOME"
    fi
fi

runvirtualenvcmd() {
    [[ -n $2 ]] || {
        echo 1>&2 "Usage: runinvirtualenv ENV CMD ..."
        return 2
    }
    local env="$1"; shift
    local envpath="$(virtualenvwrapper_absolutepath "$WORKON_HOME/$env")"
    [[ -d $envpath ]] || {
        echo 1>&2 "Cannot find virtualenv $env ($envpath)"
        return 1
    }
    local cmd="$1"; shift
    local fullcmd="$envpath/bin/$cmd"
    [[ -x $fullcmd ]] || {
        echo 1>&2 "Cannot find command $cmd in virtualenv $env"
        return 1
    }
    "$fullcmd" "$@"
}
#   This completion is broken for args after the first, since it offers
#   the virtualenv names again rather than the commands in that virtualenv.
complete -F _virtualenvs runvirtualenvcmd
